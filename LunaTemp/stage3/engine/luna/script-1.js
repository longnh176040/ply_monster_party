!function(){if(window.pc={markPhysics2dModuleAsUsed(){},markPhysics3dModuleAsUsed(){}},!DEVELOP&&!TRACE)return;const s={Physics3d:"physics3d",Physics2d:"physics2d",ParticleSystem:"particle-system"};const e=new class{constructor(){this.classes=new Map,this.methods=new Map,this.unusedModules=new Set([s.Physics3d,s.Physics2d,s.ParticleSystem]),this.saveTimerId=null,this.allClassesAreDefined=!1,window.addEventListener("luna:starting",(()=>{this.allClassesAreDefined=!0}))}registerClass(s){this.classes.has(s)||(this.classes.set(s,!0),this.save())}markClassAsUsed(s){this.classes.has(s)&&!1!==this.classes.get(s)&&(this.classes.set(s,!1),this.save())}registerMethod(s,e){this.methods.has(s)||this.methods.set(s,new Map);const t=this.methods.get(s);t.has(e)||(t.set(e,!0),this.save())}markMethodAsUsed(s,e){this.methods.has(s)||this.methods.set(s,new Map);const t=this.methods.get(s);!1!==t.get(e)&&(t.set(e,!1),this.save())}markModuleAsUsed(s){this.unusedModules.delete(s)}serialize(){const s=new Set(window.$environment.forceIncludedClasses),e=[...this.classes.entries()].filter((([s,e])=>e)).filter((([e])=>!s.has(e))).map((([s])=>({name:s,excluded:!0}))),t=[];for(const i of this.methods.keys()){if(!0===this.classes.get(i))continue;if(s.has(i))continue;const n=[...this.methods.get(i).entries()].map((([s,e])=>({name:s,excluded:e})));0===n.length&&e.push({name:i,excluded:!1}),t.push({className:i,staticMethods:[],instanceMethods:n})}for(const[t,i]of this.classes.entries()){const n=!i&&!this.methods.has(t),a=s.has(t);(n||a)&&e.push({name:t,excluded:!1})}return JSON.stringify({unusedClasses:e,unusedMethods:t,unusedModules:[...this.unusedModules]})}save(){this.saveTimerId&&clearTimeout(this.saveTimerId),this.saveTimerId=setTimeout((()=>{this.saveTimerId=null,this.allClassesAreDefined?fetch(window.location.origin+"/tracing",{method:"POST",body:this.serialize()}):this.save()}),100)}};function t(s,t,i){!Bridge.Class.$queue.includes(s)&&s.prototype&&Bridge.Class.$queue.push(s),e.markClassAsUsed(t);const n=[];s.$$inherits&&s.$$inherits.forEach((function s(e){i.has(e)||(i.add(e),e.$$inherits&&e.$$inherits.forEach(s),e.$genericTypeDefinition?(s(e.$genericTypeDefinition),e.$typeArguments.forEach(s)):n.push(e.$$fullname||e.$$name))})),n.filter((s=>s)).forEach((s=>e.markClassAsUsed(s)))}window.traceResults=e,e.EngineModules=s,window.TRACE=(s,t)=>{if(Array.isArray(s))for(let t=0;t<s.length;t++){const i=s[t],[n,...a]=i.split("#");e.registerClass(n),e.registerMethod(n,a.join("#"))}else{const[t,...i]=s.split("#");e.markClassAsUsed(t),e.markMethodAsUsed(t,i.join("#"))}};const i=/TRACE\(\s*"(.+)"/;let n=null;Object.defineProperty(window,"Bridge",{get:()=>n,set(s){if(n===s)return;!function(s){let i=null;const n=function(n,a,r,o){return!(r||a&&a.$noRegister)&&e.registerClass(n),a?i.call(s,n,"function"==typeof a?function(s,e){const i=function(...i){const n=new Set,a=e(...i);return t({},s,n),i.forEach((s=>t(s,s.$$fullname||s.$$name,n))),Array.isArray(a.inherits)&&a.inherits.forEach((s=>t(s,s.$$fullname||s.$$name,n))),a};return Object.defineProperty(i,"length",{get:()=>e.length}),i.toString=()=>e.toString(),i.$aliasInit=e.$aliasInit,i}(n,a):function(s,e){let i=e.statics||e.$statics;i||(i={},e.statics=i),["fields","events","props","ctors","methods"].some((s=>s in i))&&(i.ctors=i.ctors||{},i=i.ctors);let n=i.ctor;return n||(n=()=>{},i.ctor=n),i.ctor=function(...e){const i=new Set;t(this,s,i),n.apply(this,e)},e}(n,a),r,o):i.call(s,n,a,r,o)};Object.defineProperty(s,"define",{get:()=>n,set(s){i=s}})}(s);const a=s.fn.cacheBind;s.fn.cacheBind=(s,e,t,n)=>{const r=function(s){const e=s.toString().match(i);return e&&e[1]?e[1]:null}(e);return r&&TRACE(r),a(s,e,t,n)},n=s}})}(),function(){if(!DEVELOP&&!TRACE)return;window.shaderVariantsTraceResults=new class{constructor(){this.shaderVariants=new Map,this.saveTimerId=null}registerShaderVariant(s){const e=this.shaderVariants;e.has(s.id)||(e.set(s.id,s),this.save())}hasShaderVariant(s){return this.shaderVariants.has(s)}serialize(){const s=Array.from(this.shaderVariants.values());return JSON.stringify({variants:s})}save(){this.saveTimerId&&clearTimeout(this.saveTimerId),this.saveTimerId=setTimeout((()=>{fetch(window.location.origin+"/tracing/shader/variants",{method:"POST",body:this.serialize()})}),250)}}}();